## Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; 
опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

```shell
vagrant@vagrant:~$ type cd
cd is a shell builtin
```

По умолчанию команда `cd` является встроенной командой оболочки (т.е тип builtin). 
Она используется для смены текущей рабочей директории процесса.
Если бы она являлась внешним приложением, то при ее запуске создавался новый процесс 
и затем происходила бы смена рабочей директории только внутри этого процесса.
То есть это бы не привело к смене рабочей директории для текущего процесса.

Однако можно изменить тип `cd` на `alias`:

```shell
vagrant@vagrant:~$ alias cd='cd -L'
vagrant@vagrant:~$ type -t cd
alias
```

2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`?

Для подсчета строк, в которых совпал шаблон можно использовать флаг `-c` команды `grep`, например:

`vagrant@vagrant:~$ grep <some_string> <some_file> -c`

3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Процесс `/sbin/init` имеет PID 1:

```shell
vagrant@vagrant:~$ ps -p 1 -o args
COMMAND
/sbin/init
```

В свою очередь `init` является символьной ссылкой на систему инициализации `systemd`. Получается `systemd` является родителем всех процессов в данной виртуальной машине.

4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

Ответ: `vagrant@vagrant:~$ ls some_file 2>/dev/pts/1`
                
5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

Да. Здесь передаем содержимое файла команде grep через stdin и выводим stdout в другой файл:
```shell
vagrant@vagrant:~$ grep "2" < file > tmp
```

6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Да, если в графическом режиме запустить эмулятор терминала и ввести команду `echo "hello" > /dev/tty1`, то сообщение появится в
первом терминале tty, который доступен через сочетание клавиш `ctrl+alt+f1`.

7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

Команда `bash 5>&1` создаст новый процесс с оболочкой bash, при этом создается дескриптор с номером 5, который связываем с stdout новой оболочки.
Таким образом, все сообщения, которые будут отправлены на дескриптор 5 внутри новой оболочки будут перенаправлены на stdout.

Команда `echo netology > /proc/$$/fd/5` отправляет сообщение "netology" в дескриптор 5 текущего процесса. 
Так как мы ранее связали дескриптор 5 с stdout, то сообщение "netology" будет выведено в stdout консоли. 

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

Да, пример команды:

```shell
vagrant@vagrant:~$ ls /non-existent /etc/passwd 3>&1 1>&2 2>&3 | wc -l
/etc/passwd
1
```

9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

Этот файл отражает начальную среду окружения в тот момент когда текущий процесс оболочки был запущен.
При этом все изменения, которые могли произойти в среде с переменными окружения там отражены не будут.

Можно получить примерно такой же вывод при помощи `printenv`, но она выведет все изменения среды. 

10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

`/proc/<PID>/cmdline` - это файл для чтения, который содержит полную командную строку процесса
пока он не станет зомби. В последнем случае в этом файле ничего нет, то есть чтение из
этого файла будет возвращать 0 символов.

`/proc/<PID>/exe` - в Linux 2.2 и более поздних этот файл является символьной ссылкой, которая
содержит путь к исполняемой команде.

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

```shell
vagrant@vagrant:~$ cat /proc/cpuinfo | grep -i sse
```

Ответ: sse4_2

12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

```shell
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
```
Почитайте, почему так происходит, и как изменить поведение.

Причина в том, что когда мы запускаем удаленную команду при помощи ssh, то не происходит выделения псевдо-терминала tty.
Чтобы изменить поведение можно передать флаг `-t`, это приведет к принудительному выделению псевдо-терминала: `ssh -t localhost 'tty'`

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

Запускаем программу top и переводим ее в фон при помощи `CTRL-z`. Затем получаем ее PID при помощи команды `jobs -l` и удаляем из списка задач командой `disown top`: 
```shell
[1]+  Stopped                 top
vagrant@vagrant:~$ bg
[1]+ top &
vagrant@vagrant:~$ jobs -l
[1]+  1404 Stopped (signal)        top
vagrant@vagrant:~$ disown top
-bash: warning: deleting stopped job 1 with process group 1404
```

В результате, в другой сессии SSH (или в tmux), мы можем получить запущенное приложение top при помощи reptyr:
```shell
vagrant@vagrant:~$ reptyr 1404
```
PS: чтобы заработало на виртуалке пришлось править параметр ядра `echo 0 > /proc/sys/kernel/yama/ptrace_scope`.

14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

Команда tee читает из стандартного ввода и пишет в стандартный вывод и файлы. В данном примере, так как программа tee будет запущена от root, 
то она успешно создаст файл по пути `/root/new_file` с содержимым `string` (при этом выведет `string` в stdout).